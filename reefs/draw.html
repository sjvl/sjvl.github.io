<!DOCTYPE html>
<html lang="en">
<head>
    <title>Reefs by sjvl</title>
    <meta charset="utf-8">
    <meta name="viewport">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        #container {
            width: 100%;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #three-canvas {
            width: 100%;
            height: auto;
            max-height: 100vh;
            object-fit: contain;
            display: block;
            margin: auto;
        }
    </style>
</head>
<body>

<div id="container"></div>

<script src="./js/three.124.min.js"></script>
<script src="./js/MarchingCubes.js"></script>

<script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19"></script>
<script src="./js/STLExporter.js"></script>
<script src="./js/SVGExporter.js"></script>


<script>
    let seed = Date.now();
    let resolution = 75;
    const gridSize = 25;
    let subtract = .4;
    let strength = 0.0025;
    const radius = 2000;
    const maxIterations = 60;
    let allAlivePoints = [];
    let intervalId, iterationCount = 0;
    let light;

    let container, camera, scene, renderer, effect, group;
    let states = [];
    let isMouseDown = false;
    let previousMouseX = 0, previousMouseY = 0;
    let rotationSpeed = 0.005;

    let opaqueMesh;
    let vertexMesh;

    let penSize = .4;
    let paper = {paperWidth: 297, paperHeight: 420};
    let penColor = 0x000000; //e01616 + 0000ad
    let paperColor = 0xeae4dd //eae4dd //0x0000ad //f7d5ec;
    if(penColor === 0xffffff) paperColor = 0x000000;
    const directionalLight = new THREE.DirectionalLight(0xbbbbbb);
    directionalLight.position.set(-1., 1., 0.3)
    const ambientLight = new THREE.AmbientLight(0x080808);
    
    let rotation = true;

    function isMobile() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
            || window.innerWidth <= 768;
    }

    // Créer la GUI seulement sur mobile
    let gui;
    if (isMobile()) {
        gui = new lil.GUI();
        let obj = {
            seed: seed,
            rotation: rotation,
            'export SVG': exportToSVG,
            'create new one': createNewOne,
        };

        gui.add(obj, 'create new one').name('create a reef');
        gui.add(obj, 'rotation').name('Auto rotate').onChange((value) => {
            rotation = value;
        });    
        gui.add(obj, 'export SVG').name('export SVG');

    }

    function createNewOne() {
        location.reload();
    }
    function exportToSVG() {
        requestAnimationFrame(() => {
            try {
                captureScreenToSVGOptimized(renderer, {
                    threshold: 0.5,
                    filename: `reef-${seed}.svg`
                });
            } catch (error) {
                console.error("Erreur lors de la génération du SVG:", error);
                alert("Une erreur s'est produite lors de la génération du SVG.");
            }
        });
    }

    function isMouseOverGui(event) {
        // Si c'est un événement sur le GUI, ne pas bloquer les interactions
        const elementUnderPointer = document.elementFromPoint(
            event.touches ? event.touches[0].clientX : event.clientX,
            event.touches ? event.touches[0].clientY : event.clientY
        );
        return elementUnderPointer?.closest('.lil-gui') !== null;
    }    

    init();
    initializeGeometry();
    render();

    function init() {
        container = document.getElementById('container');

        scene = new THREE.Scene();
        group = new THREE.Group();
        scene.add(group);

        const aspect = paper.paperWidth / paper.paperHeight;
        const fov = 5; // Champ de vision en degrés
        const near = .1;
        const far = 35;

        camera = new THREE.PerspectiveCamera(
            fov,     // angle de champ de vision vertical (en degrés)
            aspect,  // ratio d'aspect (largeur / hauteur)
            near,    // plan proche
            far      // plan éloigné
        );

        camera.position.set(0, 3, 30);
        camera.lookAt(0, 0, 0);
        scene.add(camera);

        const cameraGroup = new THREE.Group();
        scene.add(cameraGroup);
        cameraGroup.add(camera);

        
        scene.add(ambientLight);  
        scene.add(directionalLight);  


        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.domElement.id = 'three-canvas'; // Ajoutez un ID au canvas
        const renderWidth = Math.round(paper.paperWidth / penSize);
        const renderHeight = Math.round(paper.paperHeight / penSize);
        renderer.setSize(renderWidth, renderHeight);
        renderer.setClearColor(paperColor);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        container.appendChild(renderer.domElement);

        document.addEventListener('mousedown', onPointerDown, { passive: false });
        document.addEventListener('mouseup', onPointerUp, { passive: false });
        document.addEventListener('mousemove', onPointerMove, { passive: false });
        document.addEventListener('touchstart', onTouchStart, { passive: false });
        document.addEventListener('touchend', onPointerUp, { passive: false });
        document.addEventListener('touchmove', onTouchMove, { passive: false });
        document.addEventListener('wheel', onMouseWheel, { passive: false });

        window.addEventListener('resize', onWindowResize, false);

        document.addEventListener('keydown', function(event) {
            if (event.key === ' ') {
                // console.log('rereefs');
                location.reload();
            }
            if (event.key === 'r') {
                // console.log('rotation');
                rotation = !rotation
            }
            if (event.key === 'p' || event.key === 'P') {
                // console.log('save');
                exportToSTL();
            }
            if (event.key === 'd' || event.key === 'D') {
                // console.log('save');
                exportToSVG();
            }
            if (event.key === 's' || event.key === 'S') {
                // console.log('save');
                exportToSTL();
                exportToSVG();
            }
        });
    }

    function DrawingMaterial(directionalLight, ambientLight) {
        // Créer le matériau de base
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uDirLightPos: { value: directionalLight.position.clone() },
                uDirLightColor: { value: new THREE.Color(0xffffff) },
                uAmbientLightColor: { value: new THREE.Color(0x000000) },
                uBaseColor: { value: new THREE.Color(paperColor) },
                uInkColor: { value: new THREE.Color(penColor) },
                uScale: { value: 2.5 },
                uAngleStep: { value: 4.0 },
                uAngle: { value: 1.1 },
                uThickness: { value: .58 },
                uRange: { value: new THREE.Vector2(0.4, 0.6) },
                uRim: { value: 0.25 },
                uNoiseScale: { value: 2.0 },
                uNoiseAmplitude: { value: .3 },
                uLinesNoiseScale: { value: 2.0 },
                uLinesNoiseAmplitude: { value: .5 }
            },
            // uniforms: {
            //     uDirLightPos: { value: directionalLight.position.clone() },
            //     uDirLightColor: { value: new THREE.Color(0xffffff) },
            //     uAmbientLightColor: { value: new THREE.Color(0x000000) },
            //     uBaseColor: { value: new THREE.Color(paperColor) },
            //     uInkColor: { value: new THREE.Color(penColor) },
            //     uScale: { value: 2.5 },
            //     uAngleStep: { value: 4.0 },
            //     uAngle: { value: 1.1 },
            //     uThickness: { value: .45 },
            //     uRange: { value: new THREE.Vector2(0.4, 0.58) },
            //     uRim: { value: 0.58 },
            //     uNoiseScale: { value: 2.0 },
            //     uNoiseAmplitude: { value: 0.05 },
            //     uLinesNoiseScale: { value: 2.0 },
            //     uLinesNoiseAmplitude: { value: 5.0 }
            // },
            
            vertexShader: `
                varying vec3 vNormal;
                varying vec2 vCoords;
                varying vec3 vCameraNormal;
                varying vec4 vWorldPosition;
                
                void main() {
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    vNormal = normalize(normalMatrix * normal);
                    vCoords = uv;
                    vCameraNormal = normalMatrix * normal;
                    vWorldPosition = modelViewMatrix * vec4(position, 1.0);
                }
            `,
            
            fragmentShader: `
                uniform vec3 uBaseColor;
                uniform vec3 uInkColor;
                uniform vec3 uDirLightPos;
                uniform vec3 uDirLightColor;
                uniform vec3 uAmbientLightColor;
                uniform float uScale;
                uniform float uAngleStep;
                uniform float uAngle;
                uniform float uThickness;
                uniform vec2 uRange;
                uniform float uRim;
                uniform float uNoiseScale;
                uniform float uNoiseAmplitude;
                uniform float uLinesNoiseScale;
                uniform float uLinesNoiseAmplitude;
                
                varying vec3 vNormal;
                varying vec2 vCoords;
                varying vec3 vCameraNormal;
                varying vec4 vWorldPosition;
                
                #define PI 3.141592653589793
                
                // Fonction de hash pour le bruit procédural
                vec2 hash(vec2 p) {
                    p = vec2(dot(p,vec2(127.1,311.7)),
                        dot(p,vec2(269.5,183.3)));
                    return -1.0 + 2.0*fract(sin(p)*43758.5453123);
                }
                
                // Fonction de bruit procédural
                float noise(in vec2 p) {
                    const float K1 = 0.366025404; // (sqrt(3)-1)/2;
                    const float K2 = 0.211324865; // (3-sqrt(3))/6;
                    
                    vec2 i = floor(p + (p.x+p.y)*K1);
                    
                    vec2 a = p - i + (i.x+i.y)*K2;
                    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);
                    vec2 b = a - o + K2;
                    vec2 c = a - 1.0 + 2.0*K2;
                    
                    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c)), 0.0);
                    
                    vec3 n = h*h*h*h*vec3(dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
                    
                    return dot(n, vec3(70.0));
                }
                
                // Fonction pour générer les lignes
                float lines(in float l, in vec2 fragCoord, in vec2 resolution, in float thickness, in float e) {
                    vec2 uv = fragCoord.xy * resolution;
                    float c = (.5 + .5 * sin(uv.x*.5));
                    float f = (c+thickness)*l;
                    f = smoothstep(.5-e, .5+e, f);
                    return f;
                }
                
                // Fonction pour le mélange
                float blendDarken(float base, float blend) {
                    return min(blend, base);
                }
                
                vec3 blendDarken(vec3 base, vec3 blend) {
                    return vec3(blendDarken(base.r,blend.r), blendDarken(base.g,blend.g), blendDarken(base.b,blend.b));
                }
                
                vec3 blendDarken(vec3 base, vec3 blend, float opacity) {
                    return (blendDarken(base, blend) * opacity + base * (1.0 - opacity));
                }
                
                void main() {
                    // Calcul de l'éclairage
                    // float directionalLightWeighting = max(dot(vNormal, uDirLightPos), 0.0);
                    float d = max(dot(vNormal, uDirLightPos), 0.0);
                    float directionalLightWeighting = d * 1.1 * 1.1 * 1.1;
                    vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;
                    float lw = length(lightWeighting);
                    
                    // Conversion de l'éclairage pour la densité des lignes
                    float l = lw;
                    l = uRange.x + l * (uRange.y - uRange.x);
                    
                    // Obtention de la direction de la normale pour l'angle des lignes
                    vec3 n = normalize(vCameraNormal);
                    float a = atan(n.y, n.x);
                    a = round(a * uAngleStep) / uAngleStep;
                    
                    // Effet d'éclairage de bord
                    float r = max(0.0, abs(dot(normalize(vNormal), normalize(-vWorldPosition.xyz))));
                    float de = 0.001 * length(vec2(dFdx(gl_FragCoord.x), dFdy(gl_FragCoord.y)));
                    float e = 0.1 * de;
                    
                    // Application du bruit aux coordonnées des lignes
                    vec2 coords = uScale * 100.0 * (vWorldPosition.xy / (de * 500.0)) + 
                                uLinesNoiseAmplitude * noise(uLinesNoiseScale * vWorldPosition.xy);
                    
                    // Application de l'effet de bord
                    float border = pow(smoothstep(0.0, 0.25, r), uRim);
                    l *= border;
                    
                    r = smoothstep(0.8, 0.8 + e, r);
                    a *= 1.0 - r;
                    
                    // Ajustement de l'angle
                    a += PI / 2.0;
                    a += uAngle;
                    
                    // Rotation des coordonnées
                    float s = sin(a);
                    float c = cos(a);
                    mat2 rot = mat2(c, -s, s, c);
                    coords = rot * coords;
                    
                    // Génération des lignes de hachure
                    float line = lines(l, coords, vec2(5.0), 
                                    uThickness + uNoiseAmplitude * noise(uNoiseScale * coords.xy), e);
                    
                    // Application de la couleur de base et de l'encre
                    gl_FragColor = vec4(blendDarken(uBaseColor, uInkColor, 1.0 - line), 1.0);
                }
            `
        });

        return material;
    }

    function initializeGeometry() {        
        states = [];
        allAlivePoints = [];
        iterationCount = 0;
        resolution = 75;
        
        initializeState();
        
        intervalId = setInterval(() => {
            if (iterationCount < maxIterations) {
                iterateGameOfLife();
                createGeometry();
            } else if (resolution < 150) {
                resolution += 75;
                createGeometry();
            } else {
                clearInterval(intervalId);
                // Attendre 3 secondes puis recharger la page
                setTimeout(() => {
                    // location.reload();
                }, 3000);
            }
        }, 50);
    }

    material = DrawingMaterial(directionalLight, ambientLight);

    function createGeometry() {
        if (effect) effect.reset();
 
        effect = new THREE.MarchingCubes(resolution, material);
        effect.position.set(0, 0, 0);

        for (const points of allAlivePoints) {
            for (const point of points) {
                effect.addBall(point.x, point.y, point.z, strength, subtract);
            }
        }

        effect.addSocleY(1, 12);
        effect.addBottomCut(.075);

        let newGeometry = effect.generateGeometry();

        if (opaqueMesh) {
            group.remove(opaqueMesh);
            opaqueMesh.geometry.dispose();
        }

        opaqueMesh = new THREE.Mesh(newGeometry, material);
        opaqueMesh.castShadow = true;
        opaqueMesh.receiveShadow = true;
        
        group.add(opaqueMesh);
    }

    function initializeState() {
        let seedIncrement = 0;
        const initialState = [];
        for (let x = 0; x < gridSize; x++) {
            for (let z = 0; z < gridSize; z++) {
                const isAlive = seededRandom(seed + seedIncrement) < .15 ? 1 : 0;
                initialState.push(isAlive);
                seedIncrement++;
            }
        }
        states.push(initialState);
    }

    function seededRandom(seed) {
        const x = Math.sin(seed) * 10000;
        return x - Math.floor(x);
    }

    function iterateGameOfLife() {
        computeNextState();
        iterationCount++;
        generatePointsFromGameOfLife();
    }

    function computeNextState() {
        const previousState = states[states.length - 1];
        const nextState = [];

        for (let x = 0; x < gridSize; x++) {
            for (let z = 0; z < gridSize; z++) {
                const isAlive = previousState[x * gridSize + z];
                const aliveNeighbors = countAliveNeighbors(previousState, x, z);

                if (isAlive && (aliveNeighbors === 2 || aliveNeighbors === 3)) {
                    nextState.push(1);
                } else if (!isAlive && aliveNeighbors === 3) {
                    nextState.push(1);
                } else {
                    nextState.push(0);
                }
            }
        }
        states.push(nextState);
    }

    function countAliveNeighbors(state, x, z) {
        const neighbors = [
            [-1, -1], [-1, 0], [-1, 1],
            [0, -1],         [0, 1],
            [1, -1], [1, 0], [1, 1]
        ];
        let count = 0;
        neighbors.forEach(([dx, dz]) => {
            const nx = x + dx;
            const nz = z + dz;
            if (nx >= 0 && nz >= 0 && nx < gridSize && nz < gridSize) {
                count += state[nx * gridSize + nz];
            }
        });
        return count;
    }

    function generatePointsFromGameOfLife() {
        const finalState = states[states.length - 1];
        const newAlivePoints = [];

        for (let x = 0; x < gridSize; x++) {
            for (let z = 0; z < gridSize; z++) {
                const isAlive = finalState[x * gridSize + z];
                if (isAlive === 1) {
                    const ballx = (x / (gridSize - 1)) * (0.67 - 0.27) + 0.27;
                    const bally = mapIterationToY(iterationCount);
                    const ballz = (z / (gridSize - 1)) * (0.67 - 0.27) + 0.27;
                    newAlivePoints.push({ x: ballx, y: bally, z: ballz });
                }
            }
        }

        allAlivePoints.push(newAlivePoints);
    }

    function mapIterationToY(iteration) {
        const minY = 0.1;
        const maxY = 0.9;
        return minY + ((maxY - minY) / maxIterations) * iteration;
    }

    function onPointerDown(event) {
        event.preventDefault();
        isMouseDown = true;
        previousMouseX = event.touches ? event.touches[0].clientX : event.clientX;
        previousMouseY = event.touches ? event.touches[0].clientY : event.clientY;
    }

    function onPointerUp(event) {
        event.preventDefault();
        isMouseDown = false;
    }

    function onPointerMove(event) {
        event.preventDefault();
        
        if (!isMouseDown) return;
        
        const clientX = event.touches ? event.touches[0].clientX : event.clientX;
        const clientY = event.touches ? event.touches[0].clientY : event.clientY;
        
        if (!isFinite(clientX) || !isFinite(clientY)) return;
        
        const deltaX = clientX - previousMouseX;
        const deltaY = clientY - previousMouseY;

        group.rotation.y += deltaX * rotationSpeed;
        group.rotation.x += deltaY * rotationSpeed;

        previousMouseX = clientX;
        previousMouseY = clientY;
    }

    function onMouseWheel(event) {
        event.preventDefault();

        const zoomFactor = 1.1;

        if (event.deltaY < 0) {
            camera.zoom *= zoomFactor;
        } else {
            camera.zoom /= zoomFactor;
        }

        camera.updateProjectionMatrix();
    }

    let touchStartDistance = 0;
    function onTouchStart(event) {
        event.preventDefault();

        if (event.touches.length === 1) {
            isMouseDown = true;
            previousMouseX = event.touches[0].clientX;
            previousMouseY = event.touches[0].clientY;
        } else if (event.touches.length === 2) {
            const dx = event.touches[0].clientX - event.touches[1].clientX;
            const dy = event.touches[0].clientY - event.touches[1].clientY;
            touchStartDistance = Math.sqrt(dx * dx + dy * dy);
        }
    }

    function onTouchMove(event) {
        event.preventDefault();
        
        if (event.touches.length === 1 && isMouseDown) {
            const clientX = event.touches[0].clientX;
            const clientY = event.touches[0].clientY;
            const deltaX = clientX - previousMouseX;
            const deltaY = clientY - previousMouseY;

            group.rotation.y += deltaX * rotationSpeed;
            group.rotation.x += deltaY * rotationSpeed;

            previousMouseX = clientX;
            previousMouseY = clientY;
        } else if (event.touches.length === 2) {
            const dx = event.touches[0].clientX - event.touches[1].clientX;
            const dy = event.touches[0].clientY - event.touches[1].clientY;
            const currentDistance = Math.sqrt(dx * dx + dy * dy);

            if (touchStartDistance > 0) {
                const zoomFactor = currentDistance / touchStartDistance;
                camera.zoom *= zoomFactor;
                camera.updateProjectionMatrix();
            }

            touchStartDistance = currentDistance;
        }
    }    

    function onWindowResize() {
        // // Récupérer les dimensions du conteneur
        const container = document.getElementById('container');
        console.log(container)

        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        console.log(containerWidth, containerHeight)
        
        // Calculer la taille pour conserver le ratio du papier (A3)
        const paperRatio = paper.paperWidth / paper.paperHeight;
        let newWidth, newHeight;
        
        if (containerWidth / containerHeight > paperRatio) {
            // Limité par la hauteur
            newHeight = containerHeight;
            newWidth = containerHeight * paperRatio;
        } else {
            // Limité par la largeur
            newWidth = containerWidth;
            newHeight = containerWidth / paperRatio;
        }
        
        // Mettre à jour la taille du rendu en gardant la résolution fixée par penSize
        const pixelsPerMM = 1 / penSize;
        const renderWidth = Math.round(paper.paperWidth * pixelsPerMM);
        const renderHeight = Math.round(paper.paperHeight * pixelsPerMM);
        
        // Garder la résolution de rendu fixe
        renderer.setSize(renderWidth, renderHeight);
        
        // Ajuster l'aspect de la caméra perspective
        camera.aspect = paperRatio;
        camera.updateProjectionMatrix();
        
        // Ajuster le style CSS du canvas pour qu'il s'adapte au conteneur
        renderer.domElement.style.width = newWidth + 'px';
        renderer.domElement.style.height = newHeight + 'px';

        if (gui) {
            if (isMobile()) {
                gui.show();
            } else {
                gui.hide();
            }
        }
    }

    function render() {
        requestAnimationFrame(render);

        if (rotation) {
            group.rotation.y += rotationSpeed;
        }

        renderer.render(scene, camera);
    }

</script>

</body>
</html>